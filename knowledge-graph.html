<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>SOMA Knowledge Graph</title>

  <!-- Bootstrap -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>

  <!-- Leaflet -->
  <link href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" rel="stylesheet">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- rdf parser -->
  <script src="https://unpkg.com/n3@1.17.4/browser/n3.min.js"></script> 

  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Merriweather:wght@700&family=Lato:wght@400;500&display=swap" rel="stylesheet">
   <link href="style.css" rel="stylesheet" />

   
  

   <style>
    :root { --indent: 16px; }
    .card { box-shadow: 0 .25rem 1rem rgba(0,0,0,.06); }
    .breadcrumb a { text-decoration: none; }
    .breadcrumb a:hover { text-decoration: underline; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Courier New", monospace; font-size:.9rem }
    .search-results { position: absolute; z-index: 1000; width: 100%; max-height: 300px; overflow-y: auto; }
    .search-item { cursor: pointer; }
    .search-item small { opacity: .7; }

    /* Friendlier property list */
    .prop-row {
      display: grid;
      grid-template-columns: 180px 1fr;
      gap: .25rem .5rem;
      padding: .5rem 0;
      border-bottom: 1px solid #f1f3f5;
    }
    @media (max-width: 768px) { .prop-row { grid-template-columns: 1fr; } }
    .prop-name {
      font-weight: 600;
      color: #374151;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      display: flex; align-items: center; gap: .5rem;
    }
    .prop-value { color: #111827; }

    /* Blank node block */
    .bn {
      background: #f8fafc;
      border-left: 4px solid #6c757d;
      border-radius: .5rem;
      padding: .5rem .75rem .5rem .75rem;
      margin: .25rem 0;
    }
    .bn .prop-row { border-bottom-color: #e9ecef; }
    .bn .prop-name { color: #495057; }
    .bn-header {
      font-size: .825rem;
      text-transform: uppercase;
      letter-spacing: .04em;
      color: #6c757d;
      margin-bottom: .25rem;
    }

    /* Indentation per level */
    .indent-0 { margin-left: 0; }
    .indent-1 { margin-left: calc(var(--indent) * 1); }
    .indent-2 { margin-left: calc(var(--indent) * 2); }
    .indent-3 { margin-left: calc(var(--indent) * 3); }
    .indent-4 { margin-left: calc(var(--indent) * 4); }
    .indent-5 { margin-left: calc(var(--indent) * 5); }

    /* Badges */
    .id-badge {
      display: inline-block;
      background: #eef2ff; 
      color: #3730a3;
      border: 1px solid #e0e7ff;
      padding: .15rem .4rem;
      border-radius: .375rem;
      font-size: .75rem;
      text-decoration: none;
      cursor: default;
    }
    /* Green variant for TYPES */
    .id-badge--type {
      background: #e8f5e9;
      color: #1b5e20;
      border-color: #c8e6c9;
    }

    /* Orange variant for CLASSES */
    .id-badge--class {
      background: #fff7ed;    
      color: #9a3412;          
      border-color: #fed7aa;   
    }
    a.id-badge, a.id-badge--class { cursor: pointer; }
    a.id-badge:hover, a.id-badge--class:hover { text-decoration: underline; }

    /*one-line incoming triple row */
    .triple-row {
      display: flex;
      align-items: center;
      gap: .5rem;
      padding: .5rem 0;
      border-bottom: 1px solid #f1f3f5;
      flex-wrap: wrap;
    }
    .triple-row .sep {
      opacity: .6;
      user-select: none;
    }
    #btnCopyUrl {
      float: right;
    }
    #pageTitle{
      color:#e9b02b;
    }
  </style>
</head>


<body class="inner-page">
  <!-- NAVBAR -->
  <nav class="navbar navbar-expand-lg bg-light fixed-top" data-bs-theme="light">
    <div class="container">
      <a class="navbar-brand" href="index.html">S O M A</a>
      <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarNav">
        <span class="navbar-toggler-icon"></span>
      </button>
      <div class="collapse navbar-collapse" id="navbarNav">
        <ul class="navbar-nav ms-auto">
          <li class="nav-item"><a class="nav-link" href="about.html">About</a></li>
          <li class="nav-item"><a class="nav-link active" href="knowledge-graph.html">Knowledge Graph</a></li>
          <li class="nav-item"><a class="nav-link" href="somavoc.html">Vocabulary</a></li>
          <li class="nav-item"><a class="nav-link" href="documentation.html">Documentation</a></li>
        </ul>
      </div>
    </div>
  </nav>

  <div class="mt-3 ms-3">
    <button id="btnBack" class="btn btn-sm btn-outline-warning back-btn" title="Go back">Back</button>
    <button id="btnCopyUrl" class="btn btn-sm btn-outline-warning me-3">Copy URL</button>
    <span id="copyStatus" class="small text-success" style="display:none;">Copied</span>
  </div>
  <div class="container pt-2 pb-4">
  
  
  <div class="container my-4">
    <!-- Header + search -->
    <div class="row align-items-center mb-3 g-2">
      <div class="col-lg-5">
        <h1 id="pageTitle" class="h3 mb-0">SOMA Knowledge Graph</h1>
      </div>
      <div class="col-lg-7">
        <div class="position-relative" >
          <input id="searchInput" class="form-control" placeholder="Search entities by name…" autocomplete="off" />
          <div id="searchResults" class="list-group search-results d-none"></div>
        </div>
      </div>
    </div>

    <!-- Controls -->
    <div class="card mb-3" id="hierarchySelector">
      <div class="card-body">
        <div class="row g-3">
          <div class="col-md-4">
            <label class="form-label">Cemetery</label>
            <select id="cemSelect" class="form-select">
              <option value="">Select…</option>
            </select>
          </div>
          <div class="col-md-4">
            <label class="form-label">Tomb <span id="tombCount" class="text-secondary"></span></label>
            <select id="tombSelect" class="form-select" disabled>
              <option value="">—</option>
            </select>
          </div>
          <div class="col-md-4">
            <label class="form-label">Burial <span id="burialCount" class="text-secondary"></span></label>
            <select id="burialSelect" class="form-select" disabled>
              <option value="">—</option>
            </select>
          </div>
        </div>

        <div class="d-flex align-items-center mt-3 gap-2 flex-wrap">
          <nav aria-label="breadcrumb" class="me-2 mb-0">
            <ol id="crumbs" class="breadcrumb mb-0"></ol>
          </nav>
        </div>
      </div>
    </div>

    <!-- Details -->
    <div class="card">
      <div class="card-header fw-semibold">Entity Details</div>
      <div class="card-body" id="entityDetails">
        <div class="text-secondary">Select an entity to see details.</div>
      </div>
    </div>
  </div>

<script>
(() => {
  const { DataFactory, Parser, Store } = N3;
  const { namedNode } = DataFactory;

  const NS = {
    rdf:  "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
    rdfs: "http://www.w3.org/2000/01/rdf-schema#",
    owl:  "http://www.w3.org/2002/07/owl#",
    xsd:  "http://www.w3.org/2001/XMLSchema#",
    crm:  "http://www.cidoc-crm.org/cidoc-crm/",
    crmarchaeo: "http://www.cidoc-crm.org/extensions/crmarchaeo/",
    schema: "http://schema.org/",
    dct: "http://purl.org/dc/terms/",
  };

  const T = {
    Cemetery: iri('crm','E27_Site'),
    Tomb:     iri('crm','E18_Physical_Thing'),
    Burial:   iri('crm','E24_Physical_Human-Made_Thing'),
    HumanRemains: iri('crm','E20_Biological_Object'),
    Object:       iri('crm','E22_Human-Made_Object'),
    VisualItem:   iri('crm','E36_Visual_Item'),
  };

  const P = {
    // load somavoc.ttl and use it to detect reusable Types

    type: nn(NS.rdf+'type'),
    label: nn(NS.rdfs+'label'),
    idBy: nn(NS.crm+'P1_is_identified_by'),
    prefId: nn(NS.crm+'P48_has_preferred_identifier'),
    idText: nn(NS.crm+'P190_has_symbolic_content'),
    isComposedOf: nn(NS.crm+'P46_is_composed_of'),
    placeWkt: nn(NS.crm+'P168_place_is_defined_by'),
    isRepBy: nn(NS.crm+'P138i_is_represented_by'),
    schemaUrl: nn(NS.schema+'url'),
  };

  let store = new Store();
  let vocTypes = new Set();
  async function loadSomavocTypes(){
    try {
      const text = await fetch('somavoc.ttl').then(r=>{ if(!r.ok) throw new Error('HTTP '+r.status); return r.text(); });
      const parser = new Parser({ format:'text/turtle' });
      const vocStore = new Store(parser.parse(text));
      const seen = new Set();
      for (const qd of vocStore.getQuads(null, null, null, null)){
        const s = qd.subject; if (s && s.termType === 'NamedNode') seen.add(s.id);
      }
      vocTypes = seen; // all terms defined in somavoc.ttl
    } catch(err){ console.warn('Could not load somavoc.ttl:', err); }
  }

  let cemIndex = [];
  let currentEntity = null;
  let searchIndex = [];
  let suppressPush = false;

  // UI refs
  const pageTitle = document.getElementById('pageTitle');
  const cemSelect = document.getElementById('cemSelect');
  const tombSelect = document.getElementById('tombSelect');
  const burialSelect = document.getElementById('burialSelect');
  const crumbs = document.getElementById('crumbs');
  const tombCount = document.getElementById('tombCount');
  const burialCount = document.getElementById('burialCount');
  const entityDetails = document.getElementById('entityDetails');
  const hierarchySelector = document.getElementById('hierarchySelector');
  const btnCopyUrl = document.getElementById('btnCopyUrl');
  const copyStatus = document.getElementById('copyStatus');
  const btnBack = document.getElementById('btnBack');

  const searchInput = document.getElementById('searchInput');
  const searchResults = document.getElementById('searchResults');

  // Helpers
  function iri(ns, local){ return NS[ns] + local; }
  function nn(v){ return namedNode(v); }
  function q(s,p,o){ return store.getQuads(s,p,o,null); }
  function one(arr){ return arr[0]; }
  function namedNodeSafe(id){ return id ? namedNode(id) : null; }
  function isURI(t){ return t && t.termType === 'NamedNode'; }
  function isBlank(t){ return t && t.termType === 'BlankNode'; }
  function isLiteral(t){ return t && t.termType === 'Literal'; }

  function shortId(iriStr){
    for (const [k,v] of Object.entries(NS)) if (iriStr && iriStr.startsWith(v)) return k+":"+iriStr.slice(v.length);
    return iriStr || '';
  }

  function isOntologyIri(iriStr){
    if (!iriStr) return false;
    return Object.values(NS).some(base => iriStr.startsWith(base));
  }

// Humanizers for classes & properties
function localFromIri(iriStr){
  if (!iriStr) return '';
  const parts = iriStr.split(/[\/#]/);
  return parts[parts.length - 1] || iriStr;
}

// Title Case but preserve hyphenated parts (e.g., "Human-Made")
function titleCase(s){
  return s.split(' ').map(w =>
    w.split('-').map(p => p ? p[0].toUpperCase()+p.slice(1).toLowerCase() : p).join('-')
  ).join(' ');
}

// Properties (predicates)
function humanizeProperty(iriStr){
  if (!iriStr) return '';

  // explicit specials
  if (iriStr === NS.rdf + 'type') return 'type';
  if (iriStr === NS.rdfs + 'label') return 'label';

  const isCidoc = iriStr.startsWith(NS.crm) || iriStr.startsWith(NS.crmarchaeo);
  let local = localFromIri(iriStr);

  if (isCidoc){
    // Strip P-code with optional trailing letter (e.g., P70i_, P82a_, P46_)
    local = local.replace(/^P\d+[a-z]?_/, '');
    // Convert remaining underscores to spaces
    local = local.replace(/_/g, ' ');
    return local.toLowerCase();
  }

  // Generic fallback: use fragment, turn underscores to spaces, lower-case
  return localFromIri(iriStr).replace(/_/g, ' ').toLowerCase();
}

// Classes
function humanizeClass(iriStr){
  if (!iriStr) return '';
  const isCidoc = iriStr.startsWith(NS.crm) || iriStr.startsWith(NS.crmarchaeo);
  let local = localFromIri(iriStr);

  if (isCidoc){
    // Strip E-code like E27_ / E18_ (number-only after E)
    local = local.replace(/^E\d+_/, '');
    local = local.replace(/_/g, ' ');
    return titleCase(local);
  }

  // Generic fallback
  return titleCase(local.replace(/_/g, ' '));
}

  function literalToFriendly(lit){ 
    return isLiteral(lit) ? lit.value : ''; 
  }

  function parseWKTPoint(wkt){
    const m = /^POINT\s*\(\s*([-\d.]+)\s+([-\d.]+)\s*\)$/i.exec(String(wkt||'').trim());
    return m ? { lon: parseFloat(m[1]), lat: parseFloat(m[2]) } : null;
  }

  let wktMapCounter = 0;

  function renderWktMiniMap(container, {lat, lon}){
    const id = 'wktmap_' + (++wktMapCounter);

    // small map box on the right
    const wrap = document.createElement('div');
    wrap.style.marginTop = '.25rem';

    const mapBox = document.createElement('div');
    mapBox.id = id;
    mapBox.style.width = '180px';
    mapBox.style.height = '120px';
    mapBox.style.borderRadius = '8px';
    mapBox.style.overflow = 'hidden';
    mapBox.style.cursor = 'pointer';
    wrap.appendChild(mapBox);
    container.appendChild(wrap);

    requestAnimationFrame(() => {
      const map = L.map(id, { zoomControl: false, attributionControl: false }).setView([lat, lon], 14);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);
      L.marker([lat, lon]).addTo(map);
      setTimeout(()=> map.invalidateSize(), 0);
    });

    mapBox.title = 'Click to enlarge';
    mapBox.onclick = () => openWktModal({lat, lon});
  }

  let wktModalEl = null, wktModalMap = null, wktModal = null;
  function openWktModal({lat, lon}){
    if (!wktModalEl){
      wktModalEl = document.createElement('div');
      wktModalEl.className = 'modal fade';
      wktModalEl.tabIndex = -1;
      wktModalEl.innerHTML = `
        <div class="modal-dialog modal-lg modal-dialog-centered">
          <div class="modal-content">
            <div class="modal-header">
              <h5 class="modal-title">Location</h5>
              <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body p-0">
              <div id="wktModalMap" style="width:100%;height:480px;"></div>
            </div>
          </div>
        </div>`;
      document.body.appendChild(wktModalEl);
      wktModal = new bootstrap.Modal(wktModalEl);
    }

    // Build (or rebuild) the Leaflet map after the modal content is inserted & shown
    const onShown = () => {
      wktModalEl.removeEventListener('shown.bs.modal', onShown);
      const host = document.getElementById('wktModalMap');
      if (!host) return;
      if (wktModalMap) { wktModalMap.remove(); wktModalMap = null; } // destroy any old instance
      wktModalMap = L.map(host).setView([lat, lon], 15);
      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',
        { attribution: '&copy; OpenStreetMap contributors' }).addTo(wktModalMap);
      L.marker([lat, lon]).addTo(wktModalMap);
      setTimeout(()=> wktModalMap.invalidateSize(), 0);
    };

    wktModalEl.addEventListener('shown.bs.modal', onShown);
    wktModal.show();
  }



  
  function labelOf(node){
    let t = q(node, P.label, null); if (t.length) return t[0].object.value;
    let ids = q(node, P.idBy, null).concat(q(node, P.prefId, null)).map(x=>x.object);
    for (const id of ids){
      let s = q(id, P.idText, null); if (s.length) return s[0].object.value;
    }
    if (node && node.id) return shortId(node.id);
    return '';
  }

  function isClass(node){
    if (!node) return false;
    return q(node, P.type, nn(NS.rdfs+'Class')).length > 0 ||
           q(node, P.type, nn(NS.owl+'Class')).length  > 0;
  }

  function classify(node){
    if (!node) return 'other';
    if (q(node, P.type, nn(T.Cemetery)).length) return 'cem';
    if (q(node, P.type, nn(T.Tomb)).length)     return 'tomb';
    if (q(node, P.type, nn(T.Burial)).length)   return 'burial';
    if (q(node, P.type, nn(T.HumanRemains)).length) return 'hr';
    if (q(node, P.type, nn(T.Object)).length)       return 'obj';
    return 'other';
  }

  function setTitle(text){
    pageTitle.textContent = text && text.trim() ? text : 'SOMA Knowledge Graph';
  }

  // Badge builder
  function makeIdBadge(iriStr, kind = 'property'){
    if (kind === 'type') {
      const a = document.createElement('a');
      a.className = 'id-badge id-badge--type';
      a.href = `somavoc.html?iri=${encodeURIComponent(iriStr)}#${encodeURIComponent(localFromIri(iriStr))}`;
      a.target = '_blank';          
      a.rel = 'noopener';
      a.textContent = humanizeClass ? humanizeClass(iriStr) : shortId(iriStr);
      a.title = shortId(iriStr);
      return a;
    }


    // Human-friendly label
    let txt;
    if (kind === 'class') {
      txt = humanizeClass ? humanizeClass(iriStr) : shortId(iriStr);
    } else if (kind === 'property') {
      txt = humanizeProperty ? humanizeProperty(iriStr) : shortId(iriStr);
    } else {
      txt = shortId(iriStr);
    }

    const isLinked = isOntologyIri(iriStr);
    const cls = kind === 'class' ? 'id-badge id-badge--class' : 'id-badge';

    const el = isLinked ? document.createElement('a') : document.createElement('span');
    el.className = cls;
    if (isLinked) {
      el.href = iriStr;
      el.target = '_blank';
      el.rel = 'noopener';
    }
    el.textContent = txt;

    // Tooltip: show full prefixed IRI (e.g., crm:P1_is_identified_by)
    el.title = shortId(iriStr);

    return el;
  }


  // Load & init
  async function loadFromUrl(url){
    const text = await fetch(url).then(r=>{ if(!r.ok) throw new Error('HTTP '+r.status); return r.text(); });
    await parseTTL(text);
    restoreFromUrlParams();
  }

  async function parseTTL(text){
    const parser = new Parser({ format:'text/turtle' });
    store = new Store(parser.parse(text));
    buildCemIndex();
    populateCemSelect();
    buildSearchIndex();
    setCrumbs();
    showEntityDetails(null);
    setTitle('');
  }

  function buildCemIndex(){
    const cem = q(null, P.type, nn(T.Cemetery)).map(t=>t.subject);
    cemIndex = cem.map(c=>({ iri:c, label:labelOf(c) }))
                  .sort((a,b)=>a.label.localeCompare(b.label));
  }

  function populateCemSelect(){
    cemSelect.innerHTML = '<option value="">Select…</option>';
    for (const c of cemIndex){
      const opt = document.createElement('option'); opt.value = c.iri.id; opt.textContent = c.label; cemSelect.appendChild(opt);
    }
    tombSelect.innerHTML = '<option value="">—</option>'; tombSelect.disabled = true; tombCount.textContent = '';
    burialSelect.innerHTML = '<option value="">—</option>'; burialSelect.disabled = true; burialCount.textContent = '';
  }

  // Search
  function buildSearchIndex(){
    const seen = new Set();
    searchIndex = [];
    for (const qd of store.getQuads(null, null, null, null)){
      const s = qd.subject;
      if (isURI(s) && !seen.has(s.id)){
        seen.add(s.id);
        searchIndex.push({ iri: s.id, label: labelOf(s) || shortId(s.id) });
      }
    }
    searchIndex.sort((a,b)=> a.label.localeCompare(b.label));
  }

  function renderSearchResults(items){
    searchResults.innerHTML = '';
    if (!items.length) {
      searchResults.classList.add('d-none');
      return;
    }
    for (const it of items.slice(0, 20)){
      const a = document.createElement('button');
      a.type = 'button';
      a.className = 'list-group-item list-group-item-action search-item';
      a.innerHTML = `<div class="d-flex justify-content-between"><span>${escape(it.label)}</span><small class="mono ms-2">${escape(shortId(it.iri))}</small></div>`;
      a.onclick = () => { searchResults.classList.add('d-none'); searchInput.value = ''; navigateToNode(namedNode(it.iri)); };
      searchResults.appendChild(a);
    }
    searchResults.classList.remove('d-none');
  }

  let searchTimer = null;
  searchInput.addEventListener('input', () => {
    const qq = searchInput.value.trim().toLowerCase();
    if (searchTimer) clearTimeout(searchTimer);
    if (!qq){ searchResults.classList.add('d-none'); searchResults.innerHTML=''; return; }
    searchTimer = setTimeout(()=>{
      const matched = searchIndex.filter(x => x.label.toLowerCase().includes(qq));
      renderSearchResults(matched);
    }, 120);
  });
  searchInput.addEventListener('keydown', (e)=>{ if (e.key==='Escape'){ searchResults.classList.add('d-none'); } });
  document.addEventListener('click', (e)=>{ if (!searchResults.contains(e.target) && e.target !== searchInput){ searchResults.classList.add('d-none'); } });

  // Selections
  function onCemeteryChange(){
    const cemIri = cemSelect.value;
    clearEntityPageParam();
    burialSelect.innerHTML = '<option value="">—</option>'; burialSelect.disabled = true; burialCount.textContent = '';

    if (!cemIri){
      tombSelect.innerHTML = '<option value="">—</option>'; tombSelect.disabled = true; tombCount.textContent = '';
      setCrumbs(); updateUrl(); showEntityDetails(null); setTitle(''); return;
    }

    const cemetery = cemIndex.find(c=>c.iri.id===cemIri);
    const tombs = descendantsOfType(cemetery.iri, T.Tomb)
      .sort((a,b)=>labelOf(a).localeCompare(labelOf(b)));

    tombSelect.innerHTML = '<option value="">Select tomb…</option>';
    for (const t of tombs){
      const opt = document.createElement('option'); opt.value = t.id; opt.textContent = labelOf(t); tombSelect.appendChild(opt);
    }
    tombSelect.disabled = !tombs.length;
    tombCount.textContent = `(${tombs.length})`;

    setCrumbs({ cemetery: cemetery.label });
    updateUrl({push: true});
    showEntityDetails(cemetery.iri);
    setTitle(cemetery.label);
  }

  function onTombChange(){
    const tombIri = tombSelect.value;
    clearEntityPageParam();

    if (!tombIri){
      burialSelect.innerHTML = '<option value="">—</option>'; burialSelect.disabled = true; burialCount.textContent = '';
      setCrumbs({ cemetery: currentCemLabel() }); updateUrl({push: true}); showEntityDetails(namedNodeSafe(cemSelect.value)); setTitle(currentCemLabel()); return;
    }

    const tomb = namedNode(tombIri);
    const burials = q(tomb, P.isComposedOf, null)
      .map(t=>t.object)
      .filter(b => q(b, P.type, nn(T.Burial)).length)
      .sort((a,b)=>labelOf(a).localeCompare(labelOf(b)));


    burialSelect.innerHTML = '<option value="">Select burial…</option>';
    for (const b of burials){
      const opt = document.createElement('option'); opt.value = b.id; opt.textContent = labelOf(b); burialSelect.appendChild(opt);
    }
    burialSelect.disabled = !burials.length;
    burialCount.textContent = `(${burials.length})`;

    setCrumbs({ cemetery: currentCemLabel(), tomb: labelOf(tomb) });
    updateUrl({push: true});
    showEntityDetails(tomb);
    setTitle(labelOf(tomb));
  }

  function onBurialChange(){
    const burialIri = burialSelect.value;
    clearEntityPageParam();

    if (!burialIri){
      setCrumbs({ cemetery: currentCemLabel(), tomb: currentTombLabel() }); updateUrl({push: true}); showEntityDetails(namedNodeSafe(tombSelect.value)); setTitle(currentTombLabel() || currentCemLabel()); return;
    }
    const burial = namedNode(burialIri);
    setCrumbs({ cemetery: currentCemLabel(), tomb: currentTombLabel(), burial: labelOf(burial) });
    updateUrl({push: true});
    showEntityDetails(burial);
    setTitle(labelOf(burial));
  }

  // Breadcrumbs
  function setCrumbs(parts = {}) {
    const items = [];
    if (parts.cemetery) {
      items.push(`<li class="breadcrumb-item"><a href="#" onclick="selectLevel('cem')">${escape(parts.cemetery)}</a></li>`);
    }
    if (parts.tomb) {
      items.push(`<li class="breadcrumb-item"><a href="#" onclick="selectLevel('tomb')">${escape(parts.tomb)}</a></li>`);
    }
    if (parts.burial) {
      items.push(`<li class="breadcrumb-item"><a href="#" onclick="selectLevel('burial')">${escape(parts.burial)}</a></li>`);
    }
    crumbs.innerHTML = items.join('');
  }

  window.selectLevel = function(level) {
    clearEntityPageParam();
    if (level === 'cem') {
      tombSelect.value = '';
      burialSelect.value = '';
      onCemeteryChange();
    } else if (level === 'tomb') {
      burialSelect.value = '';
      onTombChange();
    }
    updateUrl({push: true});
  };

  // Renderers
  function appendPropRow(container, pred, valueNode){
    const row = document.createElement('div');
    row.className = 'prop-row';

    const name = document.createElement('div');
    name.className = 'prop-name';
    name.appendChild(makeIdBadge(pred.id, 'property'));  // blue badge for property

    const value = document.createElement('div');
    value.className = 'prop-value';
    value.appendChild(renderObjectValue(valueNode, 0, new Set(), pred.id)); // pass predicate for rdf:type

    row.appendChild(name);
    row.appendChild(value);
    container.appendChild(row);

    if (pred.id === P.placeWkt.id && isLiteral(valueNode)) {
      const pt = parseWKTPoint(valueNode.value);
      if (pt) {
        renderWktMiniMap(value, pt);
      }
    }
  }

  function isInternalEntity(node){
    // Internal = appears as a subject in the store
    return q(node, null, null).length > 0;
  }

  function renderObjectValue(obj, depth = 0, visited = new Set(), contextPredIri = null){
    const frag = document.createDocumentFragment();

    if (isLiteral(obj)) {
      const span = document.createElement('span');
      span.textContent = literalToFriendly(obj);
      frag.appendChild(span);
      return frag;
    }

    if (isURI(obj)) {
      // If this IRI is a SOMAVOC type, show a green TYPE badge linking to somavoc.html
      if (vocTypes && vocTypes.has(obj.id)) {
        frag.appendChild(makeIdBadge(obj.id, 'type'));
        return frag;
      }

      const isTypeContext = contextPredIri === P.type.id;

      // 1) type/class: orange badge
      if (vocTypes && vocTypes.has(obj.id)) {
        frag.appendChild(makeIdBadge(obj.id, 'type'));
      } else if (isTypeContext || isClass(obj)) {
        frag.appendChild(makeIdBadge(obj.id, 'class'));
      }
      // 2) ontology IRIs: badges with external docs
      else if (isOntologyIri(obj.id)) {
        frag.appendChild(makeIdBadge(obj.id, 'property'));
      }
      // 3) internal entities in our dataset: navigate inside the app
      else if (isInternalEntity(obj)) {
        const link = document.createElement('a');
        link.href = '#';
        link.textContent = labelOf(obj) || shortId(obj.id);
        link.onclick = (ev) => { ev.preventDefault(); navigateToNode(obj); };
        frag.appendChild(link);
      }
      // 4) external links
      else {
        const url = obj.id;

        // clickable link (always shown)
        const a = document.createElement('a');
        a.href = url;
        a.textContent = labelOf(obj) || url;
        a.target = "_blank";
        a.rel = "noopener";
        frag.appendChild(a);

        // special case: image file: embed <img>
        if (/\.(jpe?g|png|gif|webp)$/i.test(url)) {
          const img = document.createElement('img');
          img.src = url;
          img.alt = labelOf(obj) || 'Image';
          img.style.maxWidth = '20%';
          img.style.marginTop = '0.5rem';
          img.style.borderRadius = '8px';
          frag.appendChild(img);
        }

        // Special case: Sketchfab model link (embed viewer)
        if (obj.id.includes("sketchfab.com/3d-models/")) {
          const match = obj.id.match(/([0-9a-f]{32})$/); // extract 32-char model ID at the end
          if (match) {
            const modelId = match[1];
            const wrapper = document.createElement('div');
            wrapper.className = "sketchfab-embed-wrapper";
            wrapper.style.marginTop = "0.5rem";
            wrapper.innerHTML = `
              <iframe title="Sketchfab Model" frameborder="0"
                allowfullscreen mozallowfullscreen="true" webkitallowfullscreen="true"
                allow="autoplay; fullscreen; xr-spatial-tracking"
                src="https://sketchfab.com/models/${modelId}/embed"
                style="width:100%; height:480px; border-radius:8px;">
              </iframe>`;
            frag.appendChild(wrapper);
          }
        }
      }

      return frag;
    }


    if (isBlank(obj)) {
      if (visited.has(obj.id)) {
        const cyc = document.createElement('span');
        cyc.textContent = '[cycle]';
        frag.appendChild(cyc);
        return frag;
      }
      visited.add(obj.id);

      const wrap = document.createElement('div');
      wrap.className = `bn indent-${Math.min(depth,5)}`;
      const hdr = document.createElement('div');
      hdr.className = 'bn-header';
      hdr.textContent = 'Details';
      wrap.appendChild(hdr);

      const triples = store.getQuads(obj, null, null, null);
      for (const qd of triples) {
        appendPropRow(wrap, qd.predicate, qd.object);
      }
      frag.appendChild(wrap);
      return frag;
    }

    const span = document.createElement('span');
    span.textContent = String(obj && obj.value || '');
    frag.appendChild(span);
    return frag;
  }
  

  // Details (with incoming triples one-line S - P - O)
  function showEntityDetails(node) {
    entityDetails.innerHTML = '';
    if (!node) {
      entityDetails.innerHTML = '<div class="text-secondary">Select an entity to see details.</div>';
      return;
    }

    // Header line: label + entity badge (blue)
    const title = document.createElement('div');
    title.className = 'd-flex align-items-center justify-content-between flex-wrap';
    const h = document.createElement('h2');
    h.className = 'h5 mb-1';
    h.textContent = labelOf(node);
    const idBadge = makeIdBadge(node.id || '', 'entity');
    title.appendChild(h);
    title.appendChild(idBadge);
    entityDetails.appendChild(title);

    // OUTGOING properties (no limit)
    const quads = store.getQuads(node, null, null, null);
    if (!quads.length) {
      entityDetails.innerHTML += '<div class="text-secondary mt-2">No details available.</div>';
    } else {
      const box = document.createElement('div');
      box.className = 'mt-3';
      for (const t of quads) {
        const predShort = shortId(t.predicate.id);
        if (predShort.endsWith('label')) continue;
        appendPropRow(box, t.predicate, t.object);
      }
      entityDetails.appendChild(box);
    }

    // INCOMING: S - P - O (O is the current node)
    const incoming = store.getQuads(null, null, node, null)
      .filter(t => !shortId(t.predicate.id).endsWith('label'));

    if (incoming.length) {
      const incWrap = document.createElement('div');
      incWrap.className = 'mt-4';

      const incTitle = document.createElement('div');
      incTitle.className = 'fw-semibold mb-2';
      incTitle.textContent = 'Referenced by';
      incWrap.appendChild(incTitle);

      for (const t of incoming) {
        // One-line row
        const row = document.createElement('div');
        row.className = 'triple-row';

        // SUBJECT
        if (t.subject.termType === 'NamedNode') {
          const sLink = document.createElement('a');
          sLink.href = '#';
          sLink.textContent = labelOf(t.subject) || shortId(t.subject.id);
          sLink.onclick = (ev) => { ev.preventDefault(); navigateToNode(t.subject); };
          row.appendChild(sLink);
        } else {
          const sSpan = document.createElement('span');
          sSpan.className = 'mono';
          sSpan.textContent = '[]';
          row.appendChild(sSpan);
        }

        // separator
        const sep1 = document.createElement('span'); sep1.className = 'sep'; sep1.textContent = '—';
        row.appendChild(sep1);

        // PREDICATE badge (ontology link)
        row.appendChild(makeIdBadge(t.predicate.id, 'property'));

        // separator
        const sep2 = document.createElement('span'); sep2.className = 'sep'; sep2.textContent = '—';
        row.appendChild(sep2);

        // OBJECT (current node label)
        const oSpan = document.createElement('span');
        oSpan.textContent = labelOf(node) || shortId(node.id);
        row.appendChild(oSpan);

        incWrap.appendChild(row);

        // If subject is a blank node, show its details right below
        if (t.subject.termType === 'BlankNode') {
          const details = document.createElement('div');
          details.className = 'indent-1';
          details.appendChild(renderObjectValue(t.subject, 0));
          incWrap.appendChild(details);
        }
      }

      entityDetails.appendChild(incWrap);
    }
  }

  // Navigation
  function navigateToNode(node){
    const kind = classify(node);
    hierarchySelector.style.display = (kind === 'cem' || kind === 'tomb' || kind === 'burial') ? '' : 'none';
    if (kind === 'cem') {
      cemSelect.value = node.id;
      onCemeteryChange();
    } else if (kind === 'tomb') {
      ensureCemeteryForTomb(node);
      tombSelect.value = node.id;
      onTombChange();
    } else if (kind === 'burial') {
      const tomb = one(q(null, P.isComposedOf, node))?.subject;
      if (tomb) {
        ensureCemeteryForTomb(tomb);
        tombSelect.value = tomb.id;
        onTombChange();
        burialSelect.value = node.id;
        onBurialChange();
      } else {
        goToEntity(node.id);
      }
    } else {
      goToEntity(node.id);
    }
  }

  function ensureCemeteryForTomb(tombNode){
    const found = cemIndex.find(c => isComposedOf(c.iri, tombNode));
    if (found) {
      cemSelect.value = found.iri.id;
      onCemeteryChange();
    }
  }


  function goToEntity(iriStr){
    currentEntity = namedNode(iriStr);
    hierarchySelector.style.display = 'none';
    cemSelect.value = '';
    tombSelect.innerHTML = '<option value="">—</option>'; tombSelect.disabled = true; tombCount.textContent = '';
    burialSelect.innerHTML = '<option value="">—</option>'; burialSelect.disabled = true; burialCount.textContent = '';
    const label = labelOf(currentEntity);
    crumbs.innerHTML = `<li class="breadcrumb-item"><a href="#" onclick="return false;">${escape(label)}</a></li>`;
    setTitle(label);
    showEntityDetails(currentEntity);
    updateUrl({push: true});
  }

  function clearEntityPageParam(){
    if (currentEntity){
      currentEntity = null;
      const parts = {};
      const cemL = currentCemLabel(); if (cemL) parts.cemetery = cemL;
      const tombL = currentTombLabel(); if (tombL) parts.tomb = tombL;
      const burialL = burialSelect.value ? labelOf(namedNode(burialSelect.value)) : '';
      if (burialL) parts.burial = burialL;
      setCrumbs(parts);
      setTitle(burialL || tombL || cemL || '');
    }
  }

  function currentCemLabel(){ const c = cemIndex.find(x=>x.iri.id===cemSelect.value); return c?c.label:''; }
  function currentTombLabel(){ return tombSelect.value ? labelOf(namedNode(tombSelect.value)) : ''; }

  function descendantsOfType(root, classIri){
    const out = [];
    const seen = new Set();
    let frontier = [root];
    for (let depth=0; depth<8; depth++){
      const next = [];
      for (const n of frontier){
        if (!n || seen.has(n.id)) continue; seen.add(n.id);
        const parts = q(n, P.isComposedOf, null).map(t=>t.object);
        for (const p of parts){
          if (q(p, P.type, nn(classIri)).length) out.push(p);
          next.push(p);
        }
      }
      if (!next.length) break;
      frontier = next;
    }
    // de-dup while preserving order by label afterwards
    return Array.from(new Set(out));
  }


  function isComposedOf(inner, outer){
    if (!inner || !outer) return false;
    if (inner.id === outer.id) return true;
    const visited = new Set();
    let frontier = [inner];
    for (let depth=0; depth<8; depth++){
      const next = [];
      for (const p of frontier){
        if (visited.has(p.id)) continue; visited.add(p.id);
        const ups = q(p, P.isComposedOf, null).map(t=>t.object);
        for (const u of ups){ if (u.id===outer.id) return true; next.push(u); }
      }
      frontier = next; if (!frontier.length) break;
    }
    return false;
  }

  // URL sync
  function updateUrl(opts = {}){
    const { push = false } = opts;
    const params = new URLSearchParams();
    if (currentEntity) {
      params.set('entity', currentEntity.id);
    } else {
      if (cemSelect.value) params.set('cem', cemSelect.value);
      if (tombSelect.value) params.set('tomb', tombSelect.value);
      if (burialSelect.value) params.set('burial', burialSelect.value);
    }
    const qs = params.toString();
    const url = `${location.pathname}${qs ? ('?'+qs) : ''}`;
    if (push && !suppressPush) {
      history.pushState(null, '', url);
    } else {
      history.replaceState(null, '', url);
    }
  }

  function restoreFromUrlParams(){
    const params = new URLSearchParams(location.search);
    const entity = params.get('entity');
    const cem = params.get('cem');
    const tomb = params.get('tomb');
    const burial = params.get('burial');

    suppressPush = true;

    if (entity){
      goToEntity(entity);
      suppressPush = false;
      return;
    }

    cemSelect.value = '';
    tombSelect.innerHTML = '<option value="">—</option>'; tombSelect.disabled = true; tombCount.textContent = '';
    burialSelect.innerHTML = '<option value="">—</option>'; burialSelect.disabled = true; burialCount.textContent = '';

    if (cem){
      hierarchySelector.style.display = "";
      cemSelect.value = cem;
      onCemeteryChange();
      if (tomb){
        tombSelect.value = tomb;
        onTombChange();
        if (burial){
          burialSelect.value = burial;
          onBurialChange();
        }
      }
    } else {
      showEntityDetails(null);
      setTitle('');
      setCrumbs();
    }

    suppressPush = false;
  }

  window.addEventListener('popstate', () => {
    restoreFromUrlParams();
  });

  // Events
  cemSelect.onchange = onCemeteryChange;
  tombSelect.onchange = onTombChange;
  burialSelect.onchange = onBurialChange;

  btnCopyUrl.onclick = async () => {
    try {
      await navigator.clipboard.writeText(location.href);
      copyStatus.style.display = 'inline';
      setTimeout(()=> copyStatus.style.display = 'none', 1200);
    } catch(e){
      const ta = document.createElement('textarea');
      ta.value = location.href; document.body.appendChild(ta);
      ta.select(); document.execCommand('copy'); document.body.removeChild(ta);
      copyStatus.style.display = 'inline';
      setTimeout(()=> copyStatus.style.display = 'none', 1200);
    }
  };

  btnBack.onclick = () => history.back();

  // Start
  (async () => {
    try {
      await loadSomavocTypes();
      await loadFromUrl('soma.ttl');
    } catch (e) {
      console.error('Auto-load failed:', e);
    }
  })();

  // utils
  function escape(str){
    return String(str).replace(/[&<>"']/g, s => ({
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#39;'
    }[s]));
  }
})();


</script>
  </div>

  
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>